# Атака Slow Loris

Дана стаття призначена для навчання принципам **Slow Loris атаки**. Варто зазначити, що оригінальний принцип цієї атаками є **досить старим** та сучасні системи мають захист від неї. 

У **попередній статті** ми вже отримали схожу поведінку, експериментуючи з **вичерпанням воркерів Nginx**. Тепер розглянемо, як працює **Slow Loris** і як його реалізувати за допомогою **Python**.

## Дисклеймер

Під час написання цієї статті **жоден сервер не постраждав**. Сервіс `httpbin.org` було обрано виключно для **демонстраційних цілей**.  

Ми не здійснювали жодної серйозної атаки, а всі запити були **контрольованими** і призначалися для перевірки роботи коду. Ця стаття має **освітній характер** і жодним чином не заохочує до зловмисних дій.

## Вступ

Атака **Slow Lori**s ґрунтується на відкритті великої кількості з'єднань та утриманні їх відкритими якомога довше. Яким чином це досягається? Ось цитата з офіційного сайту (переклад українською за допомогою DeepL):

> Slowloris тримає з'єднання відкритими, надсилаючи часткові HTTP-запити. Він продовжує надсилати наступні заголовки через регулярні проміжки часу, щоб запобігти закриттю сокетів.

Колись, коли ця атака була реалізована та протестована у 2009 році, інтернет не був таким швидким, а веб-сервери не знали, скільки часу клієнту може знадобитися для відправлення повного запиту. Тому сервери не мали чіткого таймауту на отримання запиту від клієнта.

Замість цього, сервери закривали з'єднання, якщо протягом певного часу не отримували жодних даних, наприклад, заголовків. Однак, як тільки сервер отримував хоча б частину заголовка, він вважав з'єднання активним і продовжував його утримувати.

Сьогодні інтернет є досить швидким, а сучасні сервери мають таймаут, протягом якого клієнт повинен надіслати повний запит. У цій статті ми врахуємо цей таймаут, протестуємо атаку **Slow Loris** та з’ясуємо, наскільки вона буде ефективною.

## Визначення таймаута на відправлення запита

Щоб ефективно реалізувати **Slow Loris атаку**, спершу потрібно визначити таймаут сервера — час, протягом якого сервер тримає з’єднання відкритим, чекаючи дані. Це можна зробити за допомогою Linux утиліти `netcat` і `Wireshark` для аналізу трафіку. Для прикладу візьмемо сайт `httpbin.org` для тестування.

### Крок 1: Визначення IP-адреси

Перетворимо доменне ім’я на IP-адресу за допомогою `nslookup`:
```
$ nslookup httpbin.org
Server:		127.0.0.53
Address:	127.0.0.53#53

Non-authoritative answer:
Name:	httpbin.org
Address: 3.230.67.98
Name:	httpbin.org
Address: 3.211.25.71
```

Як бачимо, у домену httpbin.org є дві IP-адреси. Це зв’язано з балансуванням навантаження. Для нашого експерименту зосередимося на `3.230.67.98`.

### Крок 2: Аналіз трафіку у Wireshark

Відкриємо Wireshark і вкажемо фільтр для потрібної IP-адреси:
```
ip.addr eq 3.230.67.98
```

### Крок 3: Підключення через `netcat`

У терміналі підключимося до сервера без надсилання даних:

```
$ nc 3.230.67.98 443
```

Цим самим ми встановимо TCP-з’єднання, але не будемо передавати жодних даних.

### Крок 4: Визначення таймауту

У Wireshark побачимо наступне:
- Пакет `[1]` — **ACK-пакет**, який завершує TCP-рукостискання.
- Пакет `[2]` — **FIN ACK-пакет**, який завершує з’єднання.

Час між пакетом `[1]` та пакетом `[2]` можна побачити в колонці `Time`. Наприклад:

- Пакет `[1]`: **2.5 секунди**
- Пакет `[2]`: **62.67 секунди**

Різниця між ними — 60 секунд. Таким чином, таймаут сервера становить **60 секунд**.

**Примітка:** SSL Handshake не скидує таймаут.

![Timings](https://github.com/vitalya420/articles/blob/main/images/timings.png?raw=true)

## Необхідна пропускна здатність

**Slow Loris** – це про велику кількість з’єднань. Давайте порахуємо пропускну здатність вашого інтернет-з’єднання, щоб встигнути передати дані до того, як сервер закриє з’єднання через таймаут.

Для прикладу, якщо ви відкриєте 65 000 з’єднань і кожне з них передаватиме мінімальний запит `GET / HTTP/1.1\r\nHost: httpbin.org\r\nConnection: keep-alive\r\n\r\n` розмір якого 61 байт, то ось що ми отримуємо: 

```
65 000 × 61 байти = 3 965 000 байт ≈ 3.78 МБ
```

Якщо сервер має таймаут 60 секунд, то необхідна швидкість для передачі всіх цих даних:

```
3.78 МБ / 60 секунд ≈ 61 КБ/сек
```

Для підтримки такої атаки вам вистачить навіть повільного інтернет-з’єднання. Головне – це правильно розподілити запити та дотримуватися таймінгів, щоб зберігати з’єднання якомога довше без таймаутів. Не забудьте вказати заголовок `Connection: keep-alive`, щоб сервер не закривав з’єднання одразу після відповіді.

## Стратегія відкриття і тримання з'єднаннь

1. **Відкриваємо TCP-з'єднання.** Це перший крок, щоб встановити базове підключення до сервера.

2. **Визначаємо таймаут сервера.** У нашому прикладі таймаут становить **60 секунд**, але краще припустити похибку в 5 секунд, тому встановимо його на **55 секунд**.

3. **SSL Handshake.** Після встановлення TCP-з'єднання необхідно виконати SSL Handshake, щоб забезпечити захищене підключення.

4. **Відправка незавершеного HTTP-запиту.** Наприклад, стандартний запит:
```
GET / HTTP/1.1\r\n
Host: httpbin.org\r\n
Connection: keep-alive\r\n
\r     <-- Зверніть увагу! Останній \n відсутній!
```
5. **Утримання з'єднання.** Перед завершенням таймауту (на 54-55-й секунді) ми відправляємо останній байт `\n`, щоб підтримати з'єднання.

    - Після відправки `\n` запит буде вважатися завершений і таймаут оновиться, тому знову відправляємо незавершений HTTP запит та робимо відлік часу.

6. **Паралельне відкриття додаткових з'єднань.** Відправка незавершеного запиту займає декілька мілісекунд або секунд, тому в нас є достатньо часу, щоб відкрити ще сотні або навіть тисячі нових з'єднань!


Як ви можете бачити, стратегія тримання з'єднання значно відрізняється від оригінальної **Slow Loris атаки**. В одному `Connection: keep-alive` з'єднанні можна відправити сотню запитів! 

При швидкості 1 запит кожні 55 секунд і кількості 100 запитів — це тримання з'єднання **90 хвилин!** 

Звичайно, частина з'єднань може закритись, тому ми відкриватимемо їх знову.


## Як рахувати timeout?

Рахувати таймаут можна для кожного з'єднання окремо. Так буде простіше в розумінні та імплементації. Інший варіант — це групувати з'єднання та рахувати таймаут від першого сокета. Плюс цього способу в тому, що з нього витікає, що сервер отримає багато запитів в один момент, які будуть опрацьовувати в один момент.

- Якщо ви хочете **максимальне навантаження в один момент** — груповий таймаут підходить краще.

- Для **гнучкого контролю кожного з'єднання** — використовуйте окремий таймаут.

![strategy](https://github.com/vitalya420/articles/blob/main/images/image2.png?raw=true)


## Event-Driven архітектура для встановлення з'єднаннь

В цій статті ми не будемо описувати принцип `Event-Driven` архітектури, але її будемо використовувати для встановлення великої кількості з'єднань. Такий підхід буде **більш ефективний**, ніж використання потоків. Тільки уявіть собі 65 тисяч потоків! Кошмар.

Отже, для цього ми створимо цикл подій, який відстежуватиме події в сокетах, наприклад, коли сокет готовий до читання або запису. В операційних системах для цього є системні виклики, як-от `select()` чи `epoll()` в Linux, `kevent()` у деяких дистрибутивах FreeBSD і macOS, або `WaitForMultipleObjects()` у Windows.

В Python вже є вбудована бібліотека `selectors`, яка забезпечує високорівневе та ефективне мультиплексування введення/виведення. За замовчуванням модуль використовує найбільш оптимальне рішення для вашої операційної системи (`DefaultSelector()`), і саме його ми використаємо.

Основний план такий:
1. **Створюємо обов'язково неблокуючий сокет:**

```python
import socket

ADDRESS = ("3.230.67.98", 443)

def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setblocking(False) # !!! MUST HAVE
    s.connect_ex(ADDRESS) # Використовуємо connect_ex, щоб уникнути виключення
    return s
```

2. **Створюємо селектор, який моніторить сокети.** Метод `.register()` третім аргументом може містити будь-які дані. Ми будемо використовувати його для зберігання колбека — функції, яка викликатиметься, коли сокет буде готовий.

```python
import selectors

sel = selectors.DefaultSelector()

def on_connected(sock):
    print("Socket connected!!")

sock = connect()
sel.register(sock, selectors.EVENT_WRITE, on_connected)

```

3. **SSL handshake:**

```python
import ssl

ctx = ssl.create_default_ctx()

req = b'GET / HTTP/1.1\r\nConnection: keep-alive\r\n\r' # <-- no \n at the end

def delay(time, sock):
    # Implement delay logic
    sock.send(b'\n')

def on_ssl_handske_completed(sock):
    # Handshake completed
    sock.send(req)
    delay(55, sock)

def on_connected(sock):
    sock = ctx.wrap_socket(sock, ...)
    try:
        sock.do_handshake()
    except ssl.SSLWantReadError:
        ... # Handle this with selectors
    except ssl.SSLWantWriteError:
        ... # and this
```

4. **Повторюємо:**

```python
while True:
    events = sel.select()
    for selector_key, event in events:
        callback = selector_key.data
        callback(selector_key.fileobj)
```

**Це лише загальний приклад коду** та демонстрація **Event-Driven** архітектури, яка є основою **асинхронності**. Повний код ви знайдете в розділі "Корисні посилання", щоб не перевантажувати статтю. 

Однак, спробуйте імплементувати це самостійно — це буде чудовим проєктом для розуміння основ **асинхронності**.

## Запускаємо

Запустимо програму, яка створює велику кількість з'єднань і підтримує їх. Перше, на що хочу звернути увагу — після відкриття приблизно **29 тисяч** з'єднань ми почали отримувати помилку: 

```OSError [errno 99] cannot assign requested address```

Тому обмежимося цією кількістю. Кожні **55 секунд** програма відправлятиме запит і виводитиме в термінал щось на кшталт:

```
Synced 25562 sockets
```


Де `25562` — це кількість активних сокетів. Звичайно, після кожного запиту деякі з'єднання могли закритися.  

Щоб додатково перевірити кількість активних з'єднань, можна скористатися наступною командою:  


```
netstat | grep 3.230.67.98 | grep ESTABLISHED | wc -l
```


У відповідь отримаємо число, близьке до кількості активних з'єднань у програмі. Похибка можлива лише через різницю в часі між відправкою запиту та перевіркою.


![Screenshot](https://github.com/vitalya420/articles/blob/main/images/slow_loris.png?raw=true)


Однак, цієї кількості було недостатньо, щоб покласти `httpbin.org` — це свідчить про **непогану конфігурацію** сервера. Але ми просто так не здаємося!  

Давайте проведемо **повторну атаку**, використовуючи **віртуальні сервери**, кожен із яких має **свою унікальну IP-адресу**. Це дозволить значно збільшити кількість одночасних з'єднань і підвищити ефективність нашої стратегії.  

**Наступний крок — масштабування нашої атаки!**

Для посилення атаки ми використали **три сервери**, кожен із яких створював і підтримував **28 тисяч з'єднань**. У підсумку це **84 000 одночасних з'єднань** із сервером `httpbin.org`. Однак, навіть за таких умов сервер залишився **стабільним і не "поклався"**.  

![DDoS](https://github.com/vitalya420/articles/blob/main/images/ddos.png?raw=true)

### Чому атака не спрацювала?  
Це не означає, що сама атака є неефективною. Насправді, це свідчить про **відмінну конфігурацію сервера**. Правильно налаштовані таймаути, обмеження кількості з'єднань від одного клієнта та інші захисні механізми запобігли успішній атаці.  

### А як виглядає успішна атака?  
Ось приклад, як виглядатиме результат на `check-host.com` для сервера, який **вразливий до атаки**:

![CheckHost](https://github.com/vitalya420/articles/blob/main/images/broken_pipes.png?raw=true)

Помилка `Broken pipe` вказує на те, що сервер, зокрема **nginx**, не має достатньо ресурсів для обробки великої кількості з'єднань, через що з'єднання не може бути встановлено або оброблено.

Це ознака того, що сервер більше не обробляє запити через надмірну кількість з'єднань і фактично стає недоступним для користувачів.

### Висновок цього експермента

`httpbin.org` демонструє приклад хорошої конфігурації сервера, який не вразливий до кількості з'єднань, що ми тестували. Однак, це не зупиняє нас на шляху до більш масштабних тестів — можливо, наступного разу все вийде! В той же час, є сервери, які вразливі навіть до 6 тисяч з'єднань, і не витримують навантаження.

## Висновок

В цій статті ми розглянули принцип атаки **Slow Loris**, проте змінили підхід, оскільки оригінальна техніка вже не є такою вразливою сьогодні. Чи є це вразливістю в сучасних умовах? За правильного підходу та масштабування — так! Можливо, нові методи забувають старі?

## Корисні посилання
- [Код](https://pastebin.com/UBzpVE3j)
- [Slowloris Official Website (archive)](https://web.archive.org/web/20101202172737/http://ha.ckers.org/slowloris)
- [OG Slowloris Code](https://github.com/GHubgenius/slowloris.pl)  
- [epoll vs kqueue Benchmark](https://daemonforums.org/showthread.php?t=2124)  
- [Python Selectors Documentation](https://docs.python.org/uk/3.13/library/selectors.html)  
- [kqueue API Documentation](https://man.freebsd.org/cgi/man.cgi?kqueue)  
- [epoll API Documentation](https://man7.org/linux/man-pages/man7/epoll.7.html)
