# Відкручуємо SSL Pinning

Ця стаття — про те, **як переглядати захищений трафік ВАШОГО фізичного чи віртуального пристрою**.  
Для цього вам знадобиться **ROOT-доступ**, а також середовище із встановленим програмним забезпеченням для перехоплення трафіку.

## Вступ

**SSL Pinning** — це механізм, який широко використовується в додатках для захисту конфіденційних даних, що передаються між додатком і сервером. Під додатком мається на увазі будь-яка програма — чи то на мобільному пристрої, чи на десктопі. Оскільки частка мобільних додатків на ринку більша, як приклад буде розглянуто Android-застосунок.

Ні для кого не секрет, що сьогодні майже весь трафік передається через захищений протокол **TLS**.
Головна ідея полягає в тому, що пристрій довіряє серверу на основі його сертифіката. Якщо сервер є легітимним, клієнт також довірятиме йому і передаватиме захищені дані.

Тут виникає перше питання: **чому клієнт довіряє серверу на основі його сертифіката, і чи буде він довіряти моєму сертифікату**?

Відповідь дуже проста. На вашому пристрої є так звані **сертифікати довіри**, видані авторитетними центрами сертифікації (**CA**, Certificate Authority). Вони **захардкоджені** у вашу операційну систему.

Вашому самостійно створеному **SSL-сертифікату** пристрій довіряти **не буде**, оскільки він не виданий жодним із довірених центрів сертифікації.

Наступне логічне питання: **чи можна створити власний CA-сертифікат, щоб обійти SSL-пінінг?**
Ця стаття — відповідь на це питання. Тому розглянемо такі питання:
- **Для чого потрібно це робити?**  
- **Як це взагалі працює?**  
- **Відкріплюємо SSL за допомогою Frida**  
- **Впроваджуємо свій CA**  

## Для чого потрібно це робити?

Ця стаття передбачає **етичні наміри**, тому будемо говорити про тестування безпеки API мобільних додатків або парсинг відкритих даних. Часто сайти магазинів, новинних порталів чи банків мають **окреме API для мобільних додатків**, яке може відрізнятися від API вебсайту.  

Таке API **спрощує роботу**, оскільки:  
- Дані можуть подаватися у **структурованому форматі (JSON)**.  
- Може бути відсутня **CAPTCHA**.  
- Запити можуть мати **менший rate-limit** або інші особливості, які слід вивчити чи протестувати на вразливості.

Однак, це зовсім не означає, що працювати з додатком буде легше. Він може використовувати різні **механізми захисту**, такі як:  

- **Integrity Check** – перевірка цілісності додатка, щоб виявити модифікації.  
- **Proof of Work** – додаткові обчислювальні задачі для уповільнення атак.  
- **Root Checking** – виявлення root-доступу та блокування роботи на рутованих пристроях.  
- **Нативна криптографія** – використання зашифрованих нативних бібліотек, які потрібно **декомпілювати або реверсити**.  

## Як це взагалі працює?  

Існує SSL-бібліотека **OpenSSL**, а у випадку з Android – **BoringSSL**, яка є форком OpenSSL, адаптованим для потреб Android. Уся логіка перевірки сертифікатів виконується саме в цій бібліотеці. Її можна знайти у пам'яті процесу як `libssl.so`.  

Щоб це перевірити, спочатку візьміть **PID (process ID)** будь-якого процесу (крім браузера, він має свої особливості, дивіться абзац **"Додатково"**), який використовує інтернет. Далі виконайте команду:  

```bash
cat /proc/<pid>/maps | grep ssl
```

### Результат на десктопному Linux виглядатиме приблизно так:
```
7f61cbbb8000-7f61cbbcb000 r--p 00000000 00:21 186853  /usr/lib64/libssl.so.3.2.2
7f61cbbcb000-7f61cbc5d000 r-xp 00013000 00:21 186853  /usr/lib64/libssl.so.3.2.2
7f61cbc5d000-7f61cbc80000 r--p 000a5000 00:21 186853  /usr/lib64/libssl.so.3.2.2
7f61cbc80000-7f61cbc8b000 r--p 000c8000 00:21 186853  /usr/lib64/libssl.so.3.2.2
7f61cbc8b000-7f61cbc8f000 rw-p 000d3000 00:21 186853  /usr/lib64/libssl.so.3.2.2
```

Це означає, що бібліотека **libssl.so** була завантажена з `/usr/lib64/libssl.so.3.2.2`.  

### У випадку з Android результат буде іншим:  
```
/apex/com.android.conscrypt/lib/libssl.so
```  

Саме ця бібліотека відповідає за логіку SSL і перевірку сертифікатів у додатках на Android.

Однак додатки не викликають функції з цієї бібліотеки напряму. Натомість у мові програмування вже є вбудовані високорівневі бібліотеки для роботи з SSL.  

### У випадку з **Java** це:  
```
java.net.ssl
```

Ця бібліотека забезпечує зручний API для роботи з TLS-з'єднаннями, а всі низькорівневі виклики до **libssl.so** виконуються під капотом.

Отже, по логіці речей, десь у цій бібліотеці має бути функція, яка перевіряє SSL сертифікат. Він або довірений, або ні.  

Чи можна змінити цю функцію так, щоб усі сертифікати завжди були довірені?  
**Так, можна!** І це один із способів, і у нього є свої плюси та мінуси.

**Плюси:**
- Не потрібно возитися із власним CA сертифікатом.
- Швидко можна відкріпити одну програму і бачити її трафік.

**Мінуси:**
- Не працює з WebView та Flutter.

Тому, якщо вирішили взяти цей спосіб, переходьте до абзацу **Відкріплюємо SSL за допомогою Frida**, інакше переходьте до **Впроваджуємо свій CA**.

## Відкріплюємо SSL за допомогою Frida

Frida — це потужний інструмент для зворотної інженерії, який дозволяє в реальному часі змінювати поведінку програм. Він є надзвичайно корисним для аналізу та модифікації додатків, дозволяючи зручно вводити зміни в код без необхідності компіляції.

Використовуючи Frida, ми можемо за допомогою JavaScript змінювати логіку роботи програми, що є саме тим, що нам потрібно для відкріплення SSL-з'єднань!

У бібліотеці OpenSSL є функції, які відповідають за валідацію сертифіката, такі як  
`SSL_CTX_set_verify` та `SSL_set_verify`. Зосередимося на `SSL_set_verify`, оскільки саме вона відповідає за перевірку сертифіката сервера. Її сигнатура виглядає так:

```c
void SSL_set_verify(SSL *ssl, int mode, SSL_verify_cb verify_callback);
```

- **Другий аргумент (`mode`)** визначає режим перевірки сертифіката. Наприклад, значення `SSL_VERIFY_PEER` означає, що сертифікат сервера обов’язково повинен бути перевірений.  
- **Третій аргумент (`verify_callback`)** — це вказівник на функцію зворотного виклику, яка буде викликатися після верифікації сертифіката. Ця функція визначає, чи довіряти сертифікату.

Однак цей підхід зазвичай використовується для нативного коду або десктопних програм. У випадку Android механізм валідації працює інакше.

### Android і BoringSSL

В Android використовується бібліотека `BoringSSL`, яка є форком OpenSSL, адаптованим для потреб Android. В `BoringSSL` реалізовано додаткову функцію `SSL_set_custom_verify`, яка використовується в Java-бібліотеці `conscrypt` для перевірки сертифікатів.

Ця функція дозволяє задати власну логіку перевірки сертифікатів, яка виконується нативним кодом. Нижче наведено приклад із бібліотеки `conscrypt`, де викликається `SSL_set_custom_verify`:

```c++
static void NativeCrypto_SSL_set_verify(JNIEnv* env, jclass, jlong ssl_address,
                                        CONSCRYPT_UNUSED jobject ssl_holder, jint mode) {
    CHECK_ERROR_QUEUE_ON_RETURN;
    SSL* ssl = to_SSL(env, ssl_address, true);
    JNI_TRACE("ssl=%p NativeCrypto_SSL_set_verify mode=%x", ssl, mode);
    if (ssl == nullptr) {
        return;
    }
    SSL_set_custom_verify(ssl, static_cast<int>(mode), cert_verify_callback);
}
```

### Хукаємо `SSL_set_custom_verify`

Тепер ми можемо перехопити функцію `SSL_set_custom_verify` за допомогою Frida і замінити її логіку так, щоб сертифікати завжди вважалися валідними. Ось код на JavaScript:

```js
setTimeout(() => {
    // Спершу знаходимо модуль libssl.so
    const libssl = Process.getModuleByName("libssl.so");

    // Шукаємо функцію SSL_set_custom_verify.
    // getExportByName() повертає вказівник на неї
    const SSL_set_custom_verify_ptr = libssl.getExportByName("SSL_set_custom_verify");
    
    // Створюємо нативну функцію для цієї адреси, щоб мати
    // можливість викликати її
    // https://frida.re/docs/javascript-api/#nativefunction
    // https://android.googlesource.com/platform/external/boringssl/+/refs/heads/master/src/include/openssl/ssl.h#2648
    const SSL_set_custom_verify = new NativeFunction(SSL_set_custom_verify_ptr, 'void', ['pointer', 'int', 'pointer']);
    
    // Нативний callback, який завжди повертає 0
    // Це означає, що сертифікат вважається валідним
    // https://frida.re/docs/javascript-api/#nativecallback
    const alwaysTrue = new NativeCallback(() => {
        return 0;
    }, 'int', ['pointer', 'pointer']);
    
    // Замінюємо оригінальну SSL_set_custom_verify на нашу функцію,
    // яка викликає наш alwaysTrue callback
    Interceptor.replace(SSL_set_custom_verify_ptr, new NativeCallback((ctx, mode, cb) => {
        console.log("[+] SSL_set_custom_verify викликано");
        SSL_set_custom_verify(ctx, 1, alwaysTrue);
    }, 'void', ['pointer', 'int', 'pointer']));
}, 0);
```

### Пояснення коду:
1. **Пошук функції `SSL_set_custom_verify`**  
   Ми знаходимо її у модулі `libssl.so` за допомогою `getExportByName`.

2. **Створення NativeFunction**  
   Ми створюємо `NativeFunction` для `SSL_set_custom_verify`, щоб мати можливість викликати її вручну.

3. **Нативний callback (`alwaysTrue`)**  
   Цей callback завжди повертає `0`, що означає успішну перевірку сертифіката.

4. **Перехоплення і заміна функції**  
   Ми використовуємо `Interceptor.replace` для заміни оригінальної функції на нашу, яка викликає `SSL_set_custom_verify` з нашим callback.

Аби запустити скрипт виконайте команду:
```bash
frida -U -l назва_вашого_файла.js -f назва.адроїд.пакета
```

## Впроваджуємо свій CA

Особливість у тому, що WebView та Flutter не використовують `libssl.so` напряму, натомість вони перевіряють сертифікати CA самостійно. 

Для прикладу, я завантажив додаток для тестування WebView і спробував відкрити в ньому Google. Як видно на скріншоті, сторінка не завантажується, а в терміналі mitmproxy відображається помилка: клієнт не довіряє сертифікату.

![WebView Not Working](https://github.com/vitalya420/articles/blob/main/images/webview-not-working.png?raw=true)

В Android ці сертифікати зберігаються у директорії `/system/etc/security/cacerts/` і мають формат `hash.0`. Тому для того, щоб працювати з SSL-трафіком через ці платформи, потрібно додати свій сертифікат в цю директорію.

Основною проблемою є те, що ми не можемо змонтувати `/system` в Android 10+ без вимкнення dm-verity. Однак ми можемо змонтувати tempfs в `/system/etc/security/cacerts/`, що дозволить працювати тимчасово (до перезавантаження пристрою).

### Плюси цього способу:
- Працює для всього трафіку на пристрої, включаючи WebView та Flutter.
- Не потрібно втручатись в бібліотеки або програми безпосередньо.

### Мінуси:
- Можливий шум через непотрібні нам пакети, оскільки це буде стосуватись всього трафіку на пристрої.

Для цього способу рекомендується використовувати прозорі проксі у вашій програмі для перегляду трафіку. Особисто я використовую **mitmproxy** в режимі **wireguard**. 


### Додаємо власний CA сертифікат у `/system/etc/security/cacerts`

#### Крок 1. Підготовка CA сертифіката
Переконайтеся, що у вас є CA сертифікат. У нашому прикладі це сертифікат від **mitmproxy**:

```bash
➜ ls
mitmproxy-ca-cert.cer
➜ export CA_CERT=mitmproxy-ca-cert.cer
```

#### Крок 2. Конвертація сертифіката у формат PEM
Android використовує сертифікати у форматі PEM. Конвертуємо наш `.cer` файл у `.pem`:

```bash
➜ openssl x509 -in $CA_CERT -out certificate.pem
➜ ls
certificate.pem  mitmproxy-ca-cert.cer
```

#### Крок 3. Обчислення хешу сертифіката
Android зберігає сертифікати у каталозі `/system/etc/security/cacerts/` у форматі `hash.0`. Обчислюємо хеш і перейменовуємо файл:

```bash
➜ mv certificate.pem $(openssl x509 -inform PEM -subject_hash_old -in certificate.pem | head -1).0
➜ ls
c8750f0d.0  mitmproxy-ca-cert.cer
```

#### Крок 4. Переміщення сертифіката на пристрій
Використовуйте **adb**, щоб скопіювати сертифікат у тимчасову директорію пристрою:

```bash
➜ adb push c8750f0d.0 /data/local/tmp
c8750f0d.0: 1 file pushed, 0 skipped. 3.4 MB/s (1172 bytes in 0.000s)
```

---

### Додавання сертифіката в Android

1. **Отримайте root-доступ на пристрої**:
   ```bash
   ➜ adb shell
   generic_x86_arm:/ $ su 
   generic_x86_arm:/ # whoami
   root
   ```

2. **Створіть тимчасову директорію для сертифікатів**:
    ```bash
    mkdir -m 700 /data/local/tmp/certs
    ```

3. **Скопіюйте існуючі сертифікати у тимчасову директорію**:
   ```bash
   cp /system/etc/security/cacerts/* /data/local/tmp/certs/
   ```

4. **Створіть монтування tmpfs для каталогу `cacerts`**:
   ```bash
   mount -t tmpfs tmpfs /system/etc/security/cacerts/
   ```

5. **Поверніть оригінальні сертифікати до tmpfs**:
   ```bash
    mv /data/local/tmp/certs/* /system/etc/security/cacerts/
   ```

6. **Скопіюйте ваш новий сертифікат у `cacerts`**:
   ```bash
   mv /data/local/tmp/c8750f0d.0 /system/etc/security/cacerts/
   ```

7. **Оновіть права доступу та SELinux контекст**:
   ```bash
   chown root:root /system/etc/security/cacerts/*
   chmod 644 /system/etc/security/cacerts/*
   chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*
   ```

Після цього ваш сертифікат буде розпізнаний системою як довірений. WebView працюватиме як треба. 

![WebView working](https://github.com/vitalya420/articles/blob/main/images/webview-working.png?raw=true)

## Додатково

Щодо відкріплення SSL за допомогою Frida – чому браузери не працюють?  
Вони не працюють, оскільки містять власну імплементацію логіки перевірки SSL-сертифікатів. У той час як WebView використовує Chromium, де імплементацію можна переглянути самостійно у вихідному коді: [Chromium Repository](https://github.com/chromium/chromium).

Також, деякі програми можуть не довіряти SSL-сертифікатам, якщо ви додали власний CA. Наприклад, це може бути пов’язано із "прозорістю сертифікатів". В цьому випадку може знадобитися зворотне інжинірингування застосунку та пошук відповідних патчів для цієї логіки.

Однак, якщо вам нічого не допомогло, але ви впевнені, що додаток використовує `libssl.so`, тоді можна відключити перехоплення трафіку та замість цього хукнути функції `SSL_read` та `SSL_write`.


## Висновок

