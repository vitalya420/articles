# Відкручуємо SSL Pinning

Ця стаття — про те, **як переглядати захищений трафік ВАШОГО фізичного чи віртуального пристрою**.  
Для цього вам знадобиться **ROOT-доступ**. 

## Вступ

**SSL Pinning** — це механізм, який широко використовується в додатках для захисту конфіденційних даних, що передаються між додатком і сервером. Під додатком мається на увазі будь-яка програма — чи то на мобільному пристрої, чи на десктопі. Оскільки частка мобільних додатків на ринку більша, як приклад буде розглянуто Android-застосунок.

Ні для кого не секрет, що сьогодні майже весь трафік передається через захищений протокол **TLS**.
Головна ідея полягає в тому, що пристрій довіряє серверу на основі його сертифіката. Якщо сервер є легітимним, клієнт також довірятиме йому і передаватиме захищені дані.

Тут виникає перше питання: **чому клієнт довіряє серверу на основі його сертифіката, і чи буде він довіряти моєму сертифікату**?

Відповідь дуже проста. На вашому пристрої є так звані **сертифікати довіри**, видані авторитетними центрами сертифікації (**CA**, Certificate Authority). Вони **захардкоджені** у вашу операційну систему.

Вашому самостійно створеному **SSL-сертифікату** пристрій довіряти **не буде**, оскільки він не виданий жодним із довірених центрів сертифікації.

Наступне логічне питання: **чи можна створити власний CA-сертифікат, щоб обійти SSL-пінінг?**
Ця стаття — відповідь на це питання. Тому розгляено такі питання:
- **Для чого потрібно це робити?**  
- **Як це взагалі працює?**  
- **Відкріплюємо SSL за допомогою Frida**  
- **Впроваджуємо свій CA для WebView та Flutter**  

## Для чого потрібно це робити?

Ця стаття передбачає **етичні наміри**, тому будемо говорити про тестування безпеки API мобільних додатків або парсинг відкритих даних. Часто сайти магазинів, новинних порталів чи банків мають **окреме API для мобільних додатків**, яке може відрізнятися від API вебсайту.  

Таке API **спрощує роботу**, оскільки:  
- Дані можуть подаватися у **структурованому форматі (JSON)**.  
- Може бути відсутня **CAPTCHA**.  
- Авторизація може мати **менший rate-limit** або інші особливості, які слід вивчити чи протестувати на вразливості.

Однак, це зовсім не означає, що працювати з додатком буде легше. Він може використовувати різні **механізми захисту**, такі як:  

- **Integrity Check** – перевірка цілісності додатка, щоб виявити модифікації.  
- **Proof of Work** – додаткові обчислювальні задачі для уповільнення атак.  
- **Root Checking** – виявлення root-доступу та блокування роботи на рутованих пристроях.  
- **Нативна криптографія** – використання зашифрованих нативних бібліотек, які потрібно **декомпілювати або реверсити**.  

## Як це взагалі працює?  

Існує SSL-бібліотека **OpenSSL**, а у випадку з Android – **BoringSSL**, яка є форком OpenSSL, адаптованим для потреб Android. Уся логіка перевірки сертифікатів виконується саме в цій бібліотеці. Її можна знайти у пам'яті процесу як `libssl.so`.  

Щоб це перевірити, спочатку візьміть **PID (process ID)** будь-якого процесу (крім браузера, він має свої особливості), який використовує інтернет. Далі виконайте команду:  

```bash
cat /proc/<pid>/maps | grep ssl
```

### Результат на десктопному Linux виглядатиме приблизно так:
```
7f61cbbb8000-7f61cbbcb000 r--p 00000000 00:21 186853  /usr/lib64/libssl.so.3.2.2
7f61cbbcb000-7f61cbc5d000 r-xp 00013000 00:21 186853  /usr/lib64/libssl.so.3.2.2
7f61cbc5d000-7f61cbc80000 r--p 000a5000 00:21 186853  /usr/lib64/libssl.so.3.2.2
7f61cbc80000-7f61cbc8b000 r--p 000c8000 00:21 186853  /usr/lib64/libssl.so.3.2.2
7f61cbc8b000-7f61cbc8f000 rw-p 000d3000 00:21 186853  /usr/lib64/libssl.so.3.2.2
```

Це означає, що бібліотека **libssl.so** була завантажена з `/usr/lib64/libssl.so.3.2.2`.  

### У випадку з Android результат буде іншим:  
```
/apex/com.android.conscrypt/lib/libssl.so
```  

Саме ця бібліотека відповідає за логіку SSL і перевірку сертифікатів у додатках на Android.

Однак додатки не викликають функції з цієї бібліотеки напряму. Натомість у мові програмування вже є вбудовані високорівневі бібліотеки для роботи з SSL.  

### У випадку з **Java** це:  
```
java.net.ssl
```

Ця бібліотека забезпечує зручний API для роботи з TLS-з'єднаннями, а всі низькорівневі виклики до **libssl.so** виконуються під капотом.

Отже, по логіці речей, десь у цій бібліотеці має бути функція, яка перевіряє SSL сертифікат. Він або довірений, або ні.  

Чи можна змінити цю функцію так, щоб усі сертифікати завжди були довірені?  

**Саме так!**  
І вказівник на цю функцію передається як третій аргумент у функції `SSL_set_verify`. Змінивши цей вказівник, можна змусити додаток довіряти будь-якому сертифікату.

Так, це один із способів, і у нього є свої плюси та мінуси.

**Плюси:**
- Не потрібно возитися із власним CA сертифікатом.
- Швидко можна відкріпити одну програму і бачити її трафік.

**Мінуси:**
- Не працює з WebView та Flutter.

Тому, якщо вирішили взяти цей спосіб, переходьте до абзацу **Відкріплюємо SSL за допомогою Frida**, інакше переходьте до **Впроваджуємо свій CA для WebView та Flutter**.


## Відкріплюємо SSL за допомогою Frida

Frida — це потужний інструмент для зворотної інженерії, який дозволяє в реальному часі змінювати поведінку програм. Він є надзвичайно корисним для аналізу та модифікації додатків, дозволяючи зручно вводити зміни в код без необхідності компіляції.

Використовуючи Frida, ми можемо за допомогою JavaScript змінювати логіку роботи програми, що є саме тим, що нам потрібно для відкріплення SSL-з'єднань!

## Впроваджуємо свій CA для WebView та Flutter

Особливість у тому, що WebView та Flutter не використовують `libssl.so` напряму, натомість вони перевіряють сертифікати CA самостійно. В Android ці сертифікати зберігаються у директорії `/system/etc/security/cacerts/` і мають формат `hash.0`. Тому для того, щоб працювати з SSL-трафіком через ці платформи, потрібно додати свій сертифікат в цю директорію.

Основною проблемою є те, що ми не можемо змонтувати `/system` в Android 10+ без вимкнення dm-verity. Однак ми можемо змонтувати tempfs в `/system/etc/security/cacerts/`, що дозволить працювати тимчасово (до перезавантаження пристрою).

### Плюси цього способу:
- Працює для всього трафіку на пристрої, включаючи WebView та Flutter.
- Не потрібно втручатись в бібліотеки або програми безпосередньо.

### Мінуси:
- Можливий шум через непотрібні нам пакети, оскільки це буде стосуватись всього трафіку на пристрої.

