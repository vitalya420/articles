# Атака Slow Loris під капотом

Дана стаття призначена для навчання принципам **Slow Loris атаки** та написання власного скрипта на Python. Варто зазначити, що цей тип атаки є **досить старим**, і сучасні системи можуть мати захист від неї. Однак цей матеріал створений виключно для **самонавчання та розуміння** принципів роботи цієї атаки. Slow Loris все ще може бути **ефективним** проти **погано сконфігурованих серверів**.

У **попередній статті** ми вже отримали схожу поведінку, експериментуючи з **вичерпанням воркерів Nginx**. Тепер розглянемо, як працює Slow Loris і як його реалізувати за допомогою Python.

## Визначення connection timeout

Щоб ефективно реалізувати **Slow Loris атаку**, спершу потрібно визначити таймаут сервера — час, протягом якого сервер тримає з’єднання відкритим, чекаючи дані. Це можна зробити за допомогою Linux утиліти `netcat` і `Wireshark` для аналізу трафіку.

### Крок 1: Визначення IP-адреси

Перетворимо доменне ім’я на IP-адресу за допомогою `nslookup`:
```
$ nslookup httpbin.org
Server:		127.0.0.53
Address:	127.0.0.53#53

Non-authoritative answer:
Name:	httpbin.org
Address: 3.230.67.98
Name:	httpbin.org
Address: 3.211.25.71
```

Як бачимо, у домену httpbin.org є дві IP-адреси. Це зв’язано з балансуванням навантаження. Для нашого експерименту зосередимося на 3.230.67.98.

### Крок 2: Аналіз трафіку у Wireshark

Відкриємо Wireshark і вкажемо фільтр для потрібної IP-адреси:
```
ip.addr eq 3.230.67.98
```

### Крок 3: Підключення через `netcat`

У терміналі підключимося до сервера без надсилання даних:

```
$ nc 3.230.67.98 443
```

Цим самим ми встановимо TCP-з’єднання, але не будемо передавати жодних даних.

### Крок 4: Визначення таймауту

У Wireshark побачимо наступне:
- Пакет `[1]` — **ACK-пакет**, який завершує TCP-рукостискання.
- Пакет `[2]` — **FIN ACK-пакет**, який завершує з’єднання.

Час між пакетом `[1]` та пакетом `[2]` можна побачити в колонці `Time`. Наприклад:

- Пакет `[1]`: **2.5 секунди**
- Пакет `[2]`: **62.67 секунди**

Різниця між ними — 60 секунд. Таким чином, таймаут сервера становить **60 секунд**.

![Timings](https://github.com/vitalya420/articles/blob/main/images/timings.png?raw=true)

## Визначення Client Max Body Size (необов'язково)

**Slow Loris** можна комбінувати з іншими типами атак, наприклад, передавати велику кількість даних, які будуть утримуватися в оперативній пам’яті, або ж навантажувати сервер значними обсягами інформації. При цьому важливо враховувати пропускну здатність вашого інтернет-з’єднання, щоб встигнути передати дані до того, як сервер закриє з’єднання через таймаут.

Для прикладу, якщо ви відкриєте 65 000 з’єднань і кожне з них передаватиме 1 МБ даних, то: 65 000 × 1 МБ = 65 000 МБ (або **65 ГБ**). Оскільки таймаут сервера становить 60 секунд, потрібно розрахувати мінімальну швидкість передачі:
```
65 000 МБ / 60 секунд = 1083,33 МБ/сек
```

Потрібна швидкість для передачі даних — понад 1 ГБ/сек. Це величезний обсяг трафіку, і його досягти можна лише в ідеальних умовах з надпотужним інтернет-з’єднанням. Тому такий підхід ефективніший для атак усередині локальної мережі або з використанням кластеру ботнетів.

Однак **Slow Loris** це впершу в чергу про велику кількість з'єднаннь, то зосередимось на меншим по об'єму пакетах, як от `GET / HTTP/1.1\r\nHost: httpbin.org\r\nConnection: keep-alive\r\n\r\n` розмір якого 62 байт. Якщо ви відкриєте 65 000 з’єднань, загальний обсяг даних становитиме:

```
65 000 × 62 байти = 4 030 000 байт ≈ 3.84 МБ
```

Якщо сервер має таймаут 60 секунд, то необхідна швидкість для передачі всіх цих даних:
```
3.84 МБ / 60 секунд ≈ 64 КБ/сек
```
Таким чином, для підтримки такої атаки вам вистачить навіть повільного інтернет-з’єднання. Головне — не пропускна здатність, а правильний розподіл запитів і таймінги, щоб підтримувати з’єднання якомога довше, не викликаючи таймаутів. Важливим моментом є те, що потрібно передати `Connection: keep-alive`.

Однак, якщо ви все-таки вирішили відправити **більший об'єм даних**, то визначити **Client Max Body Size** можна наступним чином:
- Знайти відповідний ендпоїнт, який підтримує методи `POST`, `PATCH` або `PUT`.
- Відправити запит, вказавши заголовок `Content-Length` із бажаною кількістю байт для передачі.

```
POST /post HTTP/1.1\r\n
Host: httpbin.org\r\n
Content-Length: 1000000\r\n
\r\n
```

- Аналізуваємо відповідь:
    - Якщо вказана кількість байт **менша за Client Max Body Size**, сервер продовжить  читати ваш запит.
    - Якщо ж вказана кількість **перевищує допустимий ліміт**, сервер закриє з’єднання до завершення передачі всіх даних.


Однак, якщо ви не знайшли ендпоїнта, який підтримує `POST`, `PATCH` чи `PUT` запити, можна використати метод `GET`. У цьому випадку замість тіла запиту можна передавати "дурні" заголовки, які не мають жодного сенсу, але все одно споживають пам'ять сервера.

Ці заголовки також мають свій максимальний ліміт, який можна знайти експериментальним шляхом, поступово збільшуючи їх обсяг і спостерігаючи за відповіддю сервера.

```
GET / HTTP/1.1
Host: httpbin.org
X-Dummy-Header-1: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
X-Dummy-Header-2: bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
X-Dummy-Header-3: ccccccccccccccccccccccccccccccccccccccccccccc
...
```

Кожен заголовок займає певну кількість пам'яті на сервері. Якщо ви передасте їх достатньо багато, сервер може вичерпати ресурси, виділені для обробки запитів. Як і у випадку з тілом запиту, сервер закриє з’єднання, якщо розмір заголовків перевищить встановлений ліміт.

## Стратегія відкриття і тримання з'єднаннь

1. **Відкриваємо TCP-з'єднання.** Це перший крок, щоб встановити базове підключення до сервера.

2. **Визначаємо таймаут сервера.** У нашому прикладі таймаут становить **60 секунд**, але краще припустити похибку в 5 секунд, тому встановимо його на **55 секунд**.

3. **SSL Handshake.** Після встановлення TCP-з'єднання необхідно виконати SSL Handshake, щоб забезпечити захищене підключення.

4. **Відправка незавершеного HTTP-запиту.** Наприклад, стандартний запит:
```
GET / HTTP/1.1\r\n
Host: httpbin.org\r\n
Connection: keep-alive\r\n
\r     <-- Зверніть увагу! Останній \n відстуній!
```
5. **Утримання з'єднання.** Перед завершенням таймауту (на 54-55-й секунді) ми відправляємо останній байт `\n`, щоб підтримати з'єднання.

    - Після відправки `\n` запит буде вважатися завершений і таймаут оновиться, тому знову віправляємо незавершений HTTP запит та робимо відлік часу.

6. **Паралельне відкриття додаткових з'єднань.** Відправка незавершеного запиту займає декілька мілісекунд або секунд, тому в нас є достатньо часу, щоб відкрити ще сотні або навіть тисячі нових з'єднань!

### Як рахувати timeout?

Рахувати таймаут можна для кожного з'єднання окремо. Так буде простіше в розумінні та імплементації. Інший варіант — це групувати з'єднання та рахувати таймаут від першого сокета. Плюс цього способу в тому, що з нього витікає, що сервер отримає багато запитів в один момент, які будуть опрацьовувати в один момент.

- Якщо ви хочете максимальне навантаження в один момент — груповий таймаут підходить краще.

- Для гнучкого контролю кожного з'єднання — використовуйте окремий таймаут.

![strategy](https://github.com/vitalya420/articles/blob/main/images/image2.png?raw=true)


## Event-Driven архітектура для встановлення з'єднаннь

В цій статті ми не будемо описувати принцип `Event-Driven` архітектури, але її будемо використовувати для встановлення великої кількості з'єднань. Такий підхід буде більш ефективний, ніж використання потоків. Тільки уявіть собі 65 тисяч потоків! Кошмар.
